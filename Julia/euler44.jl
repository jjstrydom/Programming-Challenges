# Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
#
# 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
#
# It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
#
# Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised; what is the value of D?

function revPentagonal(num::Int)
    # calculates the value from the reverse of the pentagonal equation
    n = (1/6)*(1+sqrt(24*num+1))
    return n
end

function isPentagonal(num::Int)
    # tests if a value is a pentagonal value
    n = revPentagonal(num) # get the reverse of the equation
    if n == round(n)  # if this is equal to a round number it is a pentagonal number
        return true
    end
    return false  # otherwise it is not pentagonal
end

function pentagonal(n::Int)
    # calculate the pentagonal number value for the n'th number in the sequence
    num = Int(n*(3*n-1)/2)  # use the given equation
    return num
end

D = -1  # initialize the difference value, from the algorithm below it can never be negative
Dn = -Inf  # initialize the Difference pentagonal value, it can never be negative from the algorithm below

k = 2 # start from 2, since we woud like to compare to k-1

# This algorithm searches combinations of pentagonal numbers to see if their sum
# and difference is pentagonal as well. It also adjusts the search space so that
# only values are tested if they are guaranteed to result in a smaller difference,
# as the answer to the problem is the smallest difference for all numbers.
# The pentagonal series is increasing, and the delta between each of these values
# also increases with each next step. We use this fact to stop the algorithm when
# the difference between two following pentagonal numbers is larger than the smallest
# difference as no new smaller differences can exist beyond this point.
# Algorithm still takes a long time to run even after these improvements.

while k > 0
    if D < 0 # if the difference is less than one, then we have not yet found a difference that is pentagonal
        Dl = 1 # set the lower bound for n'th value for the search to 1, as we need to search all possible values
    else # if the difference is positivev we have found a difference that is pentagonal
        Dl = k - Dn  # set the lower bound so that if we find a new one it will be smaller than the current one (goal is to find smallest difference)
        if Dl < 1  # if our lower bound is less than one
            Dl = 1  # , then make the lower bound one - we cant search negative value
        end
    end
    pk = pentagonal(k)  # calculate the pentagonal value for the k'th pentagonal number
    pk_m1 = pentagonal(k-1)  # calculate the pentagonal value for the k-1'th pentagonal number
    if pk - pk_m1 > D && D > 0  # since the difference between the previous and next number grows for each increasing value of k
    # at some point this difference is larger than the difference D we have found, and at that point we can stop searching as
    # all following differences is larger than D and no new smaller difference than D can be found.
        break  # stop the search
    end
    for j = Dl:k  # search from the lower bound to the current number to ensure we only look for differences that can be smaller than the current difference
        pj = pentagonal(j)  # find the pentagonal value for the j'th number
        if pk-pj > 0 # make srue the difference is positive - we are searching backwards so all j <= k
            if isPentagonal(pk-pj) && isPentagonal(pk+pj)  # if both the sum and difference is pentagonal
                new_D = abs(pk-pj)  # our new mentagonal to be tested is the absolute of the difference
                if D < 0 || new_D < D  # if the prevous difference is negative then we have found the first pentagonal difference
                    # OR if the new diffence is smaller than the previous difference then we have found the new smallest difference
                    D = new_D  # replace the new with the old
                    Dn = Int(floor(revPentagonal(D))) # calculate which n'th number in the pentagonal series it is
                end
            end
        end
    end
    k = k + 1  # increase the search range
end

println("Result: ",D)  # print the result
